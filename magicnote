#! /bin/sh

# main function:
#   \_ Add repository ( git )
#   \_ Add snippet ( key - value pair )
#   \_ List snippets
#   \_ Show one snippet
#   \_ Modify snippet
#   \_ Search snippet
#   \_ Run snippet

# design
# basic structure:
# .bin
# .data
#   |-- main
#   `-- others(submodules)
#     |-- foo
#     `-- bar

# Data Mode is key:value = N:M

# load configuration
if [ -f ~/.magicnoterc ]; then
    source ~/.magicnoterc
elif [ -f /usr/local/etc/magicnoterc ]; then
    source /usr/local/etc/magicnoterc
fi

BINTOP=$MAGICTOP/bin
DATATOP=$MAGICTOP/var
ETCTOP=$MAGICTOP/etc

# global vars
OSNAME=`uname`

NOTEDIR=magicnote
MAINNOTE_DIR=$DATATOP/$NOTEDIR/$CURRENT
ACTION_BIN=$BINTOP/magicnote_action.lua

TMPDIR=/tmp
FPREFIX=note_
INDEX_FILENAME=index
TMP_INDEX_FILENAME=magic_index
TMP_NOTE_FILENAME=magic_note
TMP_FINAL_IDX_FILENAME=final_index
TMPFILE=$TMPDIR/$TMP_NOTE_FILENAME
TMPINDEX=$TMPDIR/$TMP_INDEX_FILENAME
FINALINDEX=$TMPDIR/$TMP_FINAL_IDX_FILENAME

function prepare()
{
    ( test -d "$DATATOP/$NOTEDIR" || mkdir -p $DATATOP/$NOTEDIR )
}

function pre_check()
{
    if [ ! -d $MAINNOTE_DIR ]; then
        echo "no source found, please add a note source at first"
        exit
    fi

    # if no index file, create a empty one
    if [ ! -f $MAINNOTE_DIR/$INDEX_FILENAME ]; then
        touch $MAINNOTE_DIR/$INDEX_FILENAME
    fi
}

function check_os()
{
    if [ $OSNAME = "Linux" ]; then
        break
    elif [ $OSNAME = "Darwin" ]; then
        break
    else
        echo "unsupport os"
        exit
    fi
}

function cal_md5()
{
    local file=$1
    if [ $OSNAME = "Linux" ]; then
        local md5v=`md5sum $file | awk {'print $1'}`
        echo $md5v
    elif [ $OSNAME = "Darwin" ]; then
        local md5v=`md5 -q $file`
        echo $md5v
    else
        echo "unsupport os, now only support Linux and MacOS"
        exit
    fi
}

function add_modify_files()
{(
    local top=$1
    cd $top;
    local update_file
    git status -s | awk {'print $2'} | while read update_file
    do
        git add $update_file
    done
    git commit -m "add new note, tagname=$tagname"
)}

function cleanup()
{
    rm -f $TMPFILE $TMPINDEX $FINALINDEX
}

function print_usage()
{
    echo "usage:";
    echo "  \_ magicnote addsource source";
    echo "  \_ magicnote list [tag1 [ tag2 ...]]";
    echo "  \_ magicnote add [-tag tagname]";
    echo "  \_ magicnote rm tag@index [tag2@index2 ...]";
    echo "  \_ magicnote edit tag@index [tag2@index2 ...]";
    echo "  \_ magicnote find tag1 tag2 ...";
    echo "  \_ magicnote run tag@index [tag2@index2 ...]";
}

function action_list()
{
    # because list tags is a very complex job, we call a lua script to do this
    if [ $# = 0 ]; then
        lua $ACTION_BIN $BINTOP list $MAINNOTE_DIR $INDEX_FILENAME
        exit
    fi

    while [ -n "$1" ]
    do
        lua $ACTION_BIN $BINTOP list $MAINNOTE_DIR $INDEX_FILENAME $1
        shift
    done
}

function action_add()
{
    # try to find the -tag arg
    local tagname
    if [ $# != 0 ] && [ $1 = "-tag" ]; then
        tagname="$2"
    fi

    # 1. add note
    # 2. add key
    # 3. collect file status and commit into local
    # 4. cleanup tmp files

    #1
    ## prepare a tmp environment
    cp $MAINNOTE_DIR/$INDEX_FILENAME $TMPINDEX
    vim $TMPFILE
    if [ ! -f $TMPFILE ]; then
        exit
    fi

    local md5v=`cal_md5 $TMPFILE`
    echo "$md5v"
    local notefile=$FPREFIX$md5v

    #2
    # because add/update key is a very complex job, we call a lua script to do
    # this job
    if [ -z "$tagname" ]; then
        read -p "input tag name:" tagname;
    fi

    #echo "tagname=$tagname"
    lua $ACTION_BIN $BINTOP add $TMPDIR magic_index $tagname $notefile > $FINALINDEX

    ## if everything is ok, move note file and index to origin place
    mv $TMPFILE $MAINNOTE_DIR/$notefile;
    mv $FINALINDEX $MAINNOTE_DIR/$INDEX_FILENAME

    #3
    add_modify_files $MAINNOTE_DIR
}

function action_rm()
{
    if [ $# = 0 ]; then
        echo "please input a file stamp, e.g. mn edit ssh@1"
        exit
    fi

    cleanup
    while [ -n "$1" ]
    do
        # find which file need to edit
        local file_sign=$1
        local file_info=`lua $ACTION_BIN $BINTOP searchkey $TMPDIR magic_index $file_sign`
        local tagname=`echo $file_info | awk {'print $1'}`
        local md5=`echo $file_info | awk {'print $2'}`

        cp $MAINNOTE_DIR/$INDEX_FILENAME $TMPINDEX
        lua $ACTION_BIN $BINTOP rm $MAINNOTE_DIR $INDEX_FILENAME $file_sign > $FINALINDEX
        mv $FINALINDEX $MAINNOTE_DIR/$INDEX_FILENAME
        (
            cd $MAINNOTE_DIR/;
            # remove this one
            git rm $FPREFIX$md5;
        )

        cleanup
        shift
    done

    add_modify_files $MAINNOTE_DIR
}

function action_edit()
{
    if [ $# = 0 ]; then
        echo "please input a file stamp, e.g. mn edit ssh@1"
        exit
    fi

    while [ -n "$1" ]
    do
        cleanup
        # copy index file to tmp dir
        cp $MAINNOTE_DIR/$INDEX_FILENAME $TMPINDEX

        # find which file need to edit
        local file_sign=$1
        local file_info=`lua $ACTION_BIN $BINTOP searchkey $TMPDIR magic_index $file_sign`
        local tagname=`echo $file_info | awk {'print $1'}`
        local md5=`echo $file_info | awk {'print $2'}`

        cp $MAINNOTE_DIR/$FPREFIX$md5 $TMPFILE
        vim $TMPFILE

        local new_md5=`cal_md5 $TMPFILE`
        if [ $new_md5 != $md5 ]; then
            lua $ACTION_BIN $BINTOP updatemd5 $TMPDIR magic_index $tagname $md5 $new_md5 > $FINALINDEX;
            # all done, move back files, first replace the old one, then call
            # git mv to the new one
            mv $TMPFILE $MAINNOTE_DIR/$FPREFIX$new_md5;
            mv $FINALINDEX $MAINNOTE_DIR/$INDEX_FILENAME;
            (
                cd $MAINNOTE_DIR/;
                git rm $FPREFIX$md5;
            )
        fi

        cleanup
        shift
    done

    add_modify_files $MAINNOTE_DIR
}

function action_find()
{
    if [ $# = 0 ]; then
        echo "please input a key of finding, e.g. find test"
        exit
    fi

    lua $ACTION_BIN $BINTOP find $MAINNOTE_DIR $INDEX_FILENAME $@
}

function action_run()
{
    if [ $# = 0 ]; then
        echo "please input a key of running, e.g. run ssh@1[#1]"
        exit
    fi

    lua $ACTION_BIN $BINTOP getnote $MAINNOTE_DIR $INDEX_FILENAME $@ > $TMPDIR/tmp_note.sh
    sh /tmp/tmp_note.sh

    # cat $TMPDIR/tmp_note.info | while read line
    # do
    #     echo "running:"$line;
    #     echo $line > /tmp/tmp_run.sh;
    #     chmod +x /tmp/tmp_run.sh;
    #     sh /tmp/tmp_run.sh;
    # done
}

function action_status()
{
    cd $DATATOP/$NOTEDIR;
    local all_folders=`ls ./`;
    echo "$all_folders" | while read folder
    do
        (
        cd $folder &&
        local origin_url=`git config --get remote.origin.url`;
        if [ $CURRENT = "$folder" ]; then
            echo "* $folder : $origin_url"
        else
            echo "  $folder : $origin_url"
        fi
        )
    done

    #cd $MAINNOTE_DIR;
    #local origin_url=`git config --get remote.origin.url`;
    #echo "@$CURRENT : $origin_url";
}

function action_push()
{(
    cd $MAINNOTE_DIR;
    git push
)}

function action_pull()
{(
    cd $MAINNOTE_DIR;
    git pull
)}

######## main #########

check_os
# check first
prepare

# print help
if [ $# = 0 ]; then
    print_usage
    exit
fi

# commands
if [ $1 = "addsource" ]; then
    if [ $# != 2 ]; then
        echo "need source address, for example: git@xxx.git"
        exit
    fi

    gitsource=$2
    git clone $gitsource $MAINNOTE_DIR
    ( cd $MAINNOTE_DIR && touch $INDEX_FILENAME && git add . && git ci -m "create index" )

elif [ $1 = "list" ]; then
    pre_check
    shift
    action_list $@
elif [ $1 = "add" ]; then
    pre_check
    shift
    cleanup
    action_add $@
    cleanup
elif [ $1 = "edit" ]; then
    pre_check
    shift
    action_edit $@
elif [ $1 = "rm" ]; then
    pre_check
    shift
    action_rm $@
elif [ $1 = "find" ]; then
    pre_check
    shift
    action_find $@
elif [ $1 = "run" ]; then
    pre_check
    shift
    action_run $@
elif [ $1 = "status" ]; then
    action_status
elif [ $1 = "push" ]; then
    action_push
elif [ $1 = "pull" ]; then
    action_pull
fi
